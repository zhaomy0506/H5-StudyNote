## 对象{object}

> 对象中不带( )都是属性,带( )都是方法,( )可以传入参数

1. 对象是JS中的一种复合数据类型
2. 相当于一个容器,在对象中可以储存各种不同类型的数据
3. 两个对象进行相等(全等)比较时,比较的是对象的<span style="color:red">**内存地址**</span>
4. 两个变量同时指向一个对象,通过一个变量修改对象时,对另外一个变量也会产生影响

## 1. 属性

1. 通常属性名是一个字符串,所以属性名可以是任何值,没有特殊需求

2. 如果属性名太特殊了,不能直接使用,需要使用[]设置

3. 也可以使用`(Symbol)`作为属性名,来添加属性 

   > 一般通过`Symbol( )`添加的属性,是不希望被修改的,隐藏的

### 检查对象是否拥有某个属性

1. `obj.hasOwnProperty('属性名')`检查自身是否拥有(不推荐使用)

2. `Object.hasOwn(对象,属性名)`(推荐使用)
3. `in` 运算符 , `xxx in obj` -> 无论在自身还是原型中都会返回true

### <a id='meiju'>枚举对象属性</a>

将对象中所有的属性全部获取叫做枚举

`console.dir(obj)`,可以在控制台打印出该对象的所有属性

还可以使用`for(xxx in obj)`语句,来枚举属性

```js
for(let i in 对象){
	console.log(对象[i])					
}
//for-in的循环体会执行多次,有几个属性就会执行几次
//每次执行时,会将一个属性名赋值给i
```

> <span style="color:red">**注意 :**</span> 并不是所有的属性都已枚举,比如,使用Symbol()添加的属性

## 2. 类(对象模板)

类是对象的模板,可以将对象中的属性或方法直接定义在类中

1. 定义后,可以通过类直接创建对象
2. 同一个类创建的对象,称为同类对象
3. 可以使用`instanceof`来检查一个对象是否由某个类创建
4. 通过类创建的对象,称为该类的实例

```js
//通过class创建一个类,使用大驼峰命名法
class MyObj{
    //通过加 sratic创建静态属性,
    sratic test = '静态属性'	//静态属性只能通过类进行访问
	//新对象创建时,constructor函数会运行
	constructor(name){
		this.name = name
    }
}
//使用new运算符创建该类的实例
let M1 = new MyObj();
console.log(M1 instanceof MyObj)	//true
```

### 旧类(构造函数)

通过function创建一个构造函数(`cunstructor`就是构造函数)

构造函数中,this指向新对象(实例化)

## 3. 原型对象

> 对象中有一个专门存储原型对象的对象`__proto__`

**原型对象也负责为对象存储属性:**

- 当我们访问对象中的属性时,会优先在自身寻找该属性
- 对象自身不包含该属性时,回去原型中找

**添加到原型对象中的情况:**

1. 在类中,通过`xxx( ){  }`添加的方法,位于原型中
2. 主动向原型中添加的属性或方法

**访问原型:**

1. `obj.__proto__`
2. `Object.getPrototypeof(对象)`

**检查某个对象是否是某个对象的原型:**`fn.prototype.isPrototypeOf(obj)` 

**原型对象中的数据:**

1. 对象中的数据
2. cunstructor(对象的构造函数)

> 1. 原型对象也有原型,这样构成一条原型链
>
> 2. 对象的复杂程度不同,原型链的长度也不同

**注意:**

1. 通过`prototype`访问到的是构造函数的原型
2. 构造函数的`__proto__`属性访问到的是Function的原型

## 4. 封装 多态 继承

### 封装

1. 对象就是一个用来存储不同属性的容器

2. 对象不仅负责属性,还负责数据安全

3. 如何确保属性安全?

   1. 私有化数据

      在需要保护的数据前加上`#`,该属性只能在类内部使用

   2. 通过创建`getName()`和`setName()`方法,控制读写权限

      ```js
      class Person {
      	#name = "孙悟空"
      	getName(){
              return this.#name
          }
      	setName(name){
              this.#name = name;
          }//常规写法
      	get name(){
              return this.#name
          }
      	set name(name){
              this.#name = name;
          }//建议写法
      }
      ```

### 多态

1. JS中不会检查参数的类型,意味着任意数据类型都可以作为参数传递
2. 要调用某个函数,无需指定类型,只需要满足某些条件
3. 走路像鸭子,叫起来像鸭子,那么他就是鸭子,程序中判断鸭子,就只判断是否满足某些条件
4. 多态为我们提供了灵活性

### 继承

1. 可以通过extends关键字完成操作

   ```js
   p1 extends Person
   ```

2. 相当于一个类中的代码继承到了新类中

3. 被继承的类称为父类(超类),继承的类称为子类

4. 子类中,可以创建同名的方法覆写父类的方法

5. 通过继承可以在不修改一个类的情况下进行拓展类

## 5. new运算符

通过new调用一个函数时,这个函数会作为构造函数使用

使用new,会发生一下事情:

1. 创建一个普通对象`{ }`,称之为新对象
2. 将构造函数的`prototype`属性设置为新对象的原型`__proto__`
3. 使用实参来执行构造函数,并将新对象设置为函数中的`this`
4. 构造函数的返回值:
   - 当返回值是一个`引用值`时,该值会作为new运算的返回值返回(<span style="color:red">**千万不要这么做!**</span>)
   - 返回值是一个原始值/没有指定返回值,则新对象`{ }`作为返回值
   - 通常构造函数不指定返回值

## 6. 属性描述符

数据属性描述符

```js
Object.defineProperty(对象,属性,{
	configurable:true, // 属性能否被配置
	enumerable:true, // 属性能否被遍历/枚举(for-in)
	writable:true, // 属性能否被修改
	value:29 // 设置属性的值
})
```

访问器属性描述符

```js
Object.defineProperty(对象,属性,{
	configurable:true, // 属性能否被配置
	enumerable:true, // 属性能否被遍历/枚举(for-in)
	get(){
        //读取属性时执行该函数
    }
	set(){
		//设置属性时执行该函数
	}
})
```
