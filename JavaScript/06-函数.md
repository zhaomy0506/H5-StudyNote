## 函数(Function)

1. JS中,函数也是一个对象,用来封装代码,方便复用

2. 每次调用函数,会产生一个新的函数作用域

   返回值为一个新建的引用值时,每次调用返回值指向不同的内存地址

## 1. 创建函数

1. **函数声明**

   使用该方法创建的函数,可以在任意位置调用,函数会被提升

   ```js
   function 函数名(形参1,形参2...){
   	语句...
   }
   ```

2. **函数表达式(匿名函数)**

   ```js
   let 函数名 = function (形参1,形参2...){
   	 代码...
   }
   ```

3. **箭头函数(匿名函数)**

   - 箭头函数中只有一个参数时,可以省略( )括号

   - 箭头函数的返回值可以直接写在箭头后
   - 箭头函数没有自己的`this`,由外层作用域决定,与调用方式无关

   ```js
   //标准形式
   (形参1,形参2...)=>{
   	语句...
   }
   //直接返回返回值
   ( )=>123		//123为函数返回值
   ```

4. **自执行函数**(IIFE)

   立即执行函数是一个匿名函数,并且只会调用一次

   可以利用IIFE来创建一个一次性函数作用域,避免变量冲突的问题

   ```js
   (function(){
   	代码...
   })()
   ```

## 2. 作用域链

当我们使用一个变量时

- JS解析器会优先在当前作用域中寻找变量
- 找到则使用,未找到,则去上一层作用域中寻找
- 一直为找到,则报错 `xxx is not defined`

> 函数作用域,在创建函数时就已经确定(词法作用域),和调用位置无关

## 3. 函数中的this

函数执行时,JS解析器,会传递一个隐含的参数`this`

1. `this`通常会指向一个对象

2. `this`所指向的对象,会根据调用方式而改变

3. 箭头函数没有自己的`this`,由外层作用域决定,与调用方式无关

### this指向情况

1. 以函数形式调用,`this`指向`window`对象,可以理解为`window.fn( )`

2. 方法调用时,`this`指向调用方方法的对象

3. 构造函数实例化的对象,`this`指向新建的对象

4. 触发DOM事件的元素,回调函数中的`this`指向该DOM对象(<span style="color:red">**箭头函数除外**</span>)

### 改变this指向

除了直接调用,还可以使用call/apply/bind方法调用

1. `fn.call(obj,arg1,arg2...)`
   
   obj 函数this指向
   
   arg1,arg2 传递的参数
2. `fn.apply(obj,[array])`
   
   obj 函数this指向
   
   array 参数以数组形式传递

> 利用call/apply调用函数时,我们可以修改函数中的this指
>
> 二者不同之处,在于参数传递形式不一样

3. `fn.bind(obj,arg1,atg2...)`方法
   - bind方法用来固定this指向，固定后this无法再改变
   - bind方法返回值为处理完后的函数，需要用变量接收
   - bind也可以固定参数值

4. 箭头函数也无法通过call/apply/band方法修改this

## 4. 回调函数

将函数作为参数传递，这个传递的函数就是回调函数

## 5. 递归函数

调用自身的函数,称为递归函数

递归的核心思想,就是将大问题拆分成一个一个小问题

编程递归函数,一定要包含两个要件:

1. 基线条件 --> 递归的终止条件
2. 递归条件 --> 如何对问题进行拆分

递归的作用和循环是一致的,不同在于,递归思路清晰,循环性能好

开发中,少用递归,尽量使用循环

尽量在使用循环麻烦时,才使用递归

## 6. arguments隐含参数

`arguments`是函数中一个隐含参数

`arguments`是一个类数组(伪数组)对象

- 类数组,和数组相似,可以通过索引来读取元素,也可以for循环变量,不能调用数组的方法
- 可以使用`Array.from()`来转换成数组
- 或者使用`...`运算符转换成数组

`arguments`是用来储存函数的实参

- 无论用户是否定义形参,实参都会储存到arguments对象中

`arguments.callee` 函数本身

> 箭头函数中没有arguments

### 可变参数（剩余参数）

```js
function fn(...args){
	console.log(args)
}
```

`...args`代表可变参数

可变参数与arguments基本一致

不同点:

1. 可变参数的名字可以自己指定
2. 可变参数是一个函数,可以使用数组的方法
3. 可变参数可以配合其他参数一起使用
4. 可变参数与其他参数一起使用时,写在最后面



## 7. 闭包

闭包就是能访问外部函数作用域中变量的函数

闭包主要隐藏一些不希望被外部访问的内容(需要占据一些内存)

> 闭包和类如何选择?
>
> 1. 需要执行次数较少时,使用闭包
> 2. 需要大量创建实例时,使用类

**构成闭包的要求:**

1. 函数的嵌套

2. 内部函数要引用外部函数中的变量

3. 内部函数要作为返回值返回

```js
function Outer(fn){
	//外部定义变量
	let i = 0;
	//返回值为一个函数,该函数中的变量,可以访问到外围函数中的变量
	return (fn)=>{
		//返回值为传进来的函数,此步等于不改变函数的基础上拓展函数
		i++;
		console.log(i)
		return fn();
    }
}
let newFn = Outer(fn)
```

**闭包的生命周期:**

1. 闭包在外部函数调用时产生,外部函数每次调用都会产生一个全新的闭包
2. 内部函数丢失时销毁

### 偏函数与柯里化

1. 偏函数

   将一个多参数的函数，固定函数的一个或多个参数，实现函数简化或复用，就叫做偏函数

   可以使用`闭包`或`bind()`来实现偏函数

   ```js
   //使用闭包来实现,首先定义一个多参数函数
   function sum(a, b, c) {
       console.log(a + b + c)
   }
   //定义一个处理函数(函数本体,固定的参数)
   function partial(fn, ...args) {
       //返回一个新函数(剩余参数,未固定的参数)
       return function (...args2) {
           //利用闭包调用原函数,传入第一次的参数+第二次的参数
           fn.call(this, ...args, ...args2)
       }
   }
   let nSum = partial(sum, 10)//接收返回的函数
   nSum(10, 10) 	//a + b + c = 30
   ```

2. 柯里化

   柯里化是一项将一个函数的调用形式为`f(a,b,c)`转换为`f(a)(b)(c)`的形式,就叫做柯里化

   ```js
   //定义一个需要处理的函数
   function sum(a, b, c) {
       console.log(a + b + c)
   }
   //定义处理函数(函数本体)
   function curry(fn) {
       //直接返回函数repeat(第一次传入的参数)
       return function repeat(...args) {
           //判断传入参数是否大于等于函数的形参
           if (args.length >= fn.length) {
               //执行原函数
               return fn(...args)
           } else {
               //返回一个新函数用来接收剩余参数
               return function (...args2) {
                   //使用递归调用自身,实现循环
                   return repeat(...args, ...args2)
               }
           }
       }
   }
   let nSum = curry(sum)
   
   nSum(10)(10)(10)
   nSum(10, 10)(10)
   ```

### 缓存函数

将自身的结果储存在一个对象中，

下次调用时，判断该对象是否拥有对应属性，

如果拥有，则直接返该属性的值

没有，则添加后返回该属性的值

### 防抖/节流

**防抖/节流** -> 稀释函数的触发方式

**防抖:**

- 持续触发时,小于间隔时间,不发触发请求
- 最后一次会触发函数

**节流:**

- 规定时间内,只触发一次

**使用防抖/节流的两种方式:**

1. 使用loadsh函数库,提供的防抖和节流的函数库
2. 自行封装代码
