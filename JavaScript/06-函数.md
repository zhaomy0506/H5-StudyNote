# 函数(Function)

JS中,函数也是一种对象,用来封装代码

## 1.创建函数

1. **函数声明**

   使用该方法创建的函数,可以在任意位置调用,函数会被提升

```js
function 函数名(形参1,形参2...){
	语句...
}
```

2. **函数表达式(匿名函数)**

```js
let 函数名 = function (形参1,形参2...){
	 代码...
}
```

3. **箭头函数(匿名函数)**

   1. 箭头函数中只有一个参数时,可以省略( )括号
   
   
      2. 箭头函数的返回值可以直接写在箭头后
   
   
   3. 箭头函数没有自己的`this`,由外层作用域决定,与调用方式无关
   
   4. 箭头函数没有`arguments`

```js
//标准形式
(形参1,形参2...)=>{
	语句...
}
//直接返回返回值
( )=>123		//123为函数返回值
```

4. **自执行函数**(IIFE)

立即执行函数是一个匿名函数,并且只会调用一次

可以利用IIFE来创建一个一次性函数作用域,避免变量冲突的问题

```js
(function(){
	代码...
})()
```

## 2.作用域链

每次调用函数,都会产生一个新的函数作用域

-> 返回值为一个新建的引用值时,每次调用返回值指向不同的内存地址

在函数中,使用一个变量时:

1. JS解析器会优先在当前作用域中寻找变量
2. 找到则使用,未找到则取上层作用域中寻找
3. 一直找到为止,则报错`xxx is not defined`

> 函数作用域,在函数创建时就已经确定,和调用位置无关(词法作用域)

## 3.this

函数执行时,JS解析器,会传递一个隐含参数`this`

1. this通常会指向一个对象
2. 箭头函数没有自己的this,由外层作用域决定,与调用方式无关

### 3.1this指向情况

1. 以函数形式调用,`this`指向`window`对象,可以理解为`window.fn( )`

2. 方法调用时,`this`指向调用方方法的对象

3. 构造函数实例化的对象,`this`指向新建的对象

4. 触发DOM事件的元素,回调函数中的`this`指向该DOM对象(**箭头函数除外**)

### 3.2改变this

函数除了直接调用,还可以使用`call`/`apply`/`bind`方法调用,利用这些方法改变this指向

`fn.call(指向对象,arg1,arg2...)`

`fn.apply(指向对象,[0arg1,arg2...])`

二者不同之处,参数传递形式不一样

#### 固定this指向

`fn.bind(obj,arg1,atg2...)`方法 -> 返回处理完的函数

- bind方法用来固定this指向，固定后this无法再改变
- bind也可以固定参数值 -> 利用返回值

## 4.arguments

1. `arguments` 也是执行函数时,传递的一个隐含参数

2. `arguments` 是一个[类数组(伪数组)](07-数组.md#类数组(伪数组))对象

3. `arguments`是用来储存函数的实参
   - 无论用户是否定义形参,实参都会储存到arguments对象中
4. `arguments.callee` 指向函数本身

> 箭头函数没有arguments

### 可变参数(剩余参数)

在定义形参时,可以使用...args来接收剩余的参数

可变参数与arguments不同点:

1. 可变参数的名字可以自己指定
2. 可变参数是一个函数,可以使用数组的方法
3. 可变参数可以配合其他参数一起使用
4. 可变参数与其他参数一起使用时,写在最后面

## 5.递归函数

调用自身的函数,称为递归函数

递归的核心思想,就是将大问题拆分成一个一个小问题

编程递归函数,一定要包含两个要件:

1. 基线条件 --> 递归的终止条件
2. 递归条件 --> 如何对问题进行拆分

递归的作用和循环是一致的,不同在于,递归思路清晰,循环性能好

开发中,少用递归,尽量使用循环

尽量在使用循环麻烦时,才使用递归

## 6.闭包

闭包就是能访问外部函数作用域中变量的函数,

作用:闭包主要用来隐藏一些不希望被外部访问的内容(需要占据一些内存)

**构成闭包的条件:**

1. 函数的嵌套
2. 内部函数需要引用外部函数中的变量
3. 内部函数要作为外部函数返回值返回

### 闭包与类如何选择?

1. 需要执行次数少时,使用闭包
2. 需要大量创建实例时,使用类

### 6.1偏函数与柯里化

1. 偏函数

将一个多参数的函数，固定函数的一个或多个参数，实现函数简化或复用，就叫做偏函数

可以使用`闭包`或`bind()`来实现偏函数

```js
//使用闭包来实现,首先定义一个多参数函数
function sum(a, b, c) {
    console.log(a + b + c)
}
//定义一个处理函数(函数本体,固定的参数)
function partial(fn, ...args) {
    //返回一个新函数(剩余参数,未固定的参数)
    return function (...args2) {
        //利用闭包调用原函数,传入第一次的参数+第二次的参数
        fn.call(this, ...args, ...args2)
    }
}
let nSum = partial(sum, 10)//接收返回的函数
nSum(10, 10) 	//a + b + c = 30
```

2. 柯里化

柯里化是一项将一个函数的调用形式为`f(a,b,c)`转换为`f(a)(b)(c)`的形式,就叫做柯里化

```js
//定义一个需要处理的函数
function sum(a, b, c) {
    console.log(a + b + c)
}
//定义处理函数(函数本体)
function curry(fn) {
    //直接返回函数repeat(第一次传入的参数)
    return function repeat(...args) {
        //判断传入参数是否大于等于函数的形参
        if (args.length >= fn.length) {
            //执行原函数
            return fn(...args)
        } else {
            //返回一个新函数用来接收剩余参数
            return function (...args2) {
                //使用递归调用自身,实现循环
                return repeat(...args, ...args2)
            }
        }
    }
}
let nSum = curry(sum)

nSum(10)(10)(10)
nSum(10, 10)(10)
```

### 6.2缓存函数

将自身的结果储存在外部函数的对象中,

下次调用时,直接判断该对象是否拥有对应属性

如果拥有,直接返回该属性的值

没有,则添加后返回该属性的值

## 6.3防抖节流

**防抖/节流** -> 稀释函数的触发方式

**防抖:**

- 持续触发时,小于间隔时间,不发触发请求
- 最后一次会触发函数

**节流:**

- 规定时间内,只触发一次

**使用防抖/节流的两种方式:**

1. 使用loadsh函数库,提供的防抖和节流的函数库
2. 自行封装代码
