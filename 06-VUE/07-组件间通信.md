# 一、组件间通信

## `props`

1. **父组件 -> 子组件** 
2. **子组件 -> 父组件**  (要求父组件先给子组件一个函数)

> 不要使用v-model修改props传进来的值,因为props是不可以修改的

## 组件自定义事件

组件自定义事件:一种组件间通信的方式,适用于 **子组件 ==> 父组件**

1. 使用场景: A是父组件,B是子组件,B想给A传递数据,那么就在A中给B绑定自定义事件(事件回调函数在A中)

2. 绑定自定义事件:

   1. 方式一:在父组件`<Demo @事件名称='test'/>`

   2. 方式二:

      备注:想让事件只触发一次,使用once修饰符或$once方法

```js
<Demo ref="demo"/>
    ....
moutend(){
    this.$refs.demo.$on('传递名称',this.test)
}//通过该方式绑定的自定义事件,回调函数要么配置在methods中,要么使用箭头函数直接撰写
```

3. 子组件触发自定义事件:`this.$emit('事件名称',数据...)`
4. 解绑自定义事件:`this.$off('事件名称')`
5. 组件上也可以使用原生DOM事件,需要使用`native`修饰符,事件会被绑定到子组件内的容器中

## 全局事件总线

全局事件总线(GlobalEventBus)

1. 一种组件间通信的方式,适用于任意组件间通信

   实现随意传递的两个必要条件

   - 所有的组件要都能访问到

   - 拥有`$on`,`$emit`,`$off` 三个方法

2. 安装全局事件总线

```js
new Vue({
	·········
    beforeCreate(){
        Vue.prototype.$bus = this//安装全局事件总线
    }，
    ·········
})
```

3. 使用事件总线：

接收数据，A组件想要接收数据，则在A组件中给`$bus`绑定自定义事件,事件的回调留在A组件自身

```js
methods(){
    demo(){....}
},
mounted(){
    this.$bus.$on('xxx',this.demo)
}
```

提供数据

```js
this.$bus.$on('xxx',数据...)
```

4. 最好在`beforeDestory`钩子中,用`$off`去解绑当前组件所用到的事件

## 插槽

作用: 让父组件向子组件指定位置插入HTML结构,也是一种通信方式,适用于 `父组件 ==> 子组件`

1. 默认插槽

```html
//父组件中
<Demo> 
    <div>html结构</div>
</Demo>
//子组件
<template>
	<div>
        <solt>-----插槽内容-------</solt>
    </div>
</template>
```

2. 具名插槽(指定插槽名称)

```html
//父组件中
<Demo> 
    <!--内部属性也可以使用v-solt:demo-->
    <template slot='demo'> 
        <div>html结构</div>
    </template>
</Demo>
//子组件
<template>
	<div>
        <!--使用name属性指定名称-->
        <solt name='demo'>-----插槽内容-------</solt>
    </div>
</template>
```

3. 作用域插槽(需要配合template标签使用)

   数据在【组件自身(子组件)】,但根据数据生成的结构需要【组件的使用者(父组件)】来进行指定

```html
//父组件中
<Demo> 
    <!--内部属性也可以使用v-solt:demo-->
    <template scope='数据名称'> 
        <div v-for='x in 数据' :key='数据.id'>{{数据.title}}</div>
    </template>
</Demo>
//子组件
<template>
	<div>
        <!--使用name属性指定名称-->
        <solt :指定名称='数据'>-----插槽内容-------</solt>
    </div>
</template>
```

# 二、Vuex

><span style="color:red">vue2中需要使用Vuex@3版本</span>
>
><span style="color:red">vue3中需要使用Vuex@4版本</span>

专门在Vue中实现集中式状态(数据)管理的【Vue插件】

## 何时使用？

1. 多个组件依赖同一状态
2. 来自不同组件的行为需要便跟同一状态

> 多个组件需要共享数据

## VueX工作原理:

VueComponent (人)

acrions 行为、动作 (服务员)

mutations 加工、维护 (厨师)

state 状态对象 (菜品)

<img src="../img/vuex.png" style="zoom: 33%;" />

## 搭建Vuex环境

```js
//创建文件 ./src/store/index.js
//引入Vue核心库与Vuex
import Vue from 'vue'
import Vuex form 'vuex'
//安装Vuex插件
Vue.use(vuex)
//创建并导出store
export defalut new Vuex.store({
    actions:{},//用于响应组件中用户的动作
    mutations:{},//用于修改state中的数据
    state:{}//用于存储数据
})
```

> 准备好相关文件后,需要在main.js文件中引入并在常见vue实例(vm)的时候,传入store配置项

