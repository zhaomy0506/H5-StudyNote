## Behavior混入

类似于Vue中的Mixin，`Behavior`在小程序中也充当了类似的角色，允许你在多个组件中共享一些通用的逻辑和属性。基本使用如下：

1. 创建一个Behavior，可以是单独的js文件，如：

```js
// behavior.js
export default Behavior({
  // 这里可以定义共享的属性和方法
});
```

2. 在组件的json文件中，使用`behaviors`字段引入对应的`Behavior`，如：

```json
// component.json
{
  "behaviors": ["path/to/behavior"]
}
```



## observers数据监听

`observers`用于在小程序组件中监听和响应数据的变化。它只能用于组件内部，通过监听指定的数据字段来触发回调函数，从而实现数据的响应式更新。基本使用如下：

```js
codeComponent({
  properties: {
    // 这里定义要监听的数据字段
    someData: {
      type: String,
      value: '',
      observer(newVal, oldVal) {
        // 在数据变化时触发的回调
        console.log('数据变化了：', newVal, oldVal);
      }
    }
  }
});
```



## 小程序路由跳转

小程序的路由跳转是页面导航的核心。以下是常用的路由跳转API及其应用场景：

1. `wx.switchTab({url:'路径'})`

切换到Tab页面，关闭其他非TabBar页面，适用于快速不同功能模块之间的切换。

2. `wx.navigateTo({url:'路径'})`

在当前页面保留的情况下跳转到功能页面，不能跳转到TabBar页面(一级页面)，用于不关闭当前页面的导航。

3. `wx.redirectTo({url:'路径'})`

关闭当前页面并跳转到页面，不允许跳转到TabBar页面，适用于流程性页面跳转。

4. `wx.reLaunch({url:'路径'})`

关闭所有页面，包括TabBar页面，允许跳转到一级页面，适用于全面页面切换。

5. `wx.navigateBack({delta:"后退几步"})`

从历史记录中后退指定步数，实现返回上一页面的操作。



## 页面栈

小程序使用页面栈来管理页面跳转，最多支持10层页面。超过10层后，页面将无法进行跳转

在开发中一般不应超过5层页面，你可以通过`getCurrentPages()`函数查看页面栈的内容

## 页面通信的方式

### 全局数据

可以在`app.js`中定义全局的数据，通过`getApp()`方法获取它们，然后在不同页面中共享使用。

### 本地缓存

使用`wx.setStorage`和`wx.getStorage`等API来实现数据的持久化存储。例如：

```js
// 存储数据
wx.setStorage({
  key: 'keyName',
  data: 'value'
});

// 获取数据
wx.getStorage({
  key: 'keyName',
  success(res) {
    console.log('获取数据：', res.data);
  }
});
```



### 路由传参

通过路由跳转时，可以在`url`中附加参数，然后在目标页面的`onLoad`函数中获取参数。

```js
// 在源页面跳转到目标页面并传递参数
wx.navigateTo({
  url: '目标页面路径?key=value'
});

// 在目标页面获取参数
Page({
  onLoad(options) {
    console.log('接收到参数：', options.key);
  }
});
```

## 网络请求

小程序中使用wx.request发送请求,但又一些限制:

1. 必须使用HTTPS进行网络请求

2. 请求的域名必须在小程序的后台设置中合法

   小程序后台 ==> 开发管理 ==>开发设置 ==> 服务器域名

3. 在开发阶段，可以勾选"不校验合法域名"选项，但上线后仍需满足前两个条件

   右上角 ==> 详情 ==本地设置 ==> 不校验合法域名

```js
wx.request({
  url: '请求地址',
  method: 'GET', // 默认为GET请求
  data: {}, // 请求参数
  header: {}, // 请求头
  success(res) {
    // 请求成功的处理
    console.log('请求成功', res.data);
  },
  fail(error) {
    // 请求失败的处理
    console.error('请求失败', error);
  }
});
```

