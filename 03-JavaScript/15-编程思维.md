## 冒泡排序和比较排序区别

二者区别在于

- 一个是与自身相邻的比较
- 一个是拿自身向后比较

```js
//冒泡排序
const arr = [3, 2, 4, 1, 5, 7, 9, 6, 0, 8]
//控制比较的轮数
for (let i = 0; i < arr.length; i++) {
    //拿当前索引和索引+1比较,索引一直在变(j++)
    for (let j = 0; j < arr.length - 1; j++) {
        if (arr[j] > arr[j + 1]) {
            let flag = arr[i];
            arr[j] = arr[j + 1];
            arr[j] = flag;
        }
    }
}
```

```js
//选择排序
const arr = [3, 2, 4, 1, 5, 7, 9, 6, 0, 8]
//控制用谁(arr[i])比较,每轮i+1
for (let i = 0; i < arr.length; i++) {
    //控制跟谁(arrj)比较
    for (j = i + 1; j < arr.length; j++) {
        if (arr[i] > arr[j]) {
            let flag = arr[i]
            arr[i] = arr[j]
            arr[j] = flag
        }
    }
}
```

## 递归函数

调用自身的函数,称为递归函数

递归的核心思想,就是将大问题拆分成一个一个小问题

编程递归函数,一定要包含两个要件:

1. 基线条件 --> 递归的终止条件
2. 递归条件 --> 如何对问题进行拆分

递归的作用和循环是一致的,不同在于,递归思路清晰,循环性能好

开发中,少用递归,尽量使用循环

尽量在使用循环麻烦时,才使用递归

## 偏函数与柯里化

1. 偏函数

   将一个多参数的函数，固定函数的一个或多个参数，实现函数简化或复用，就叫做偏函数

   可以使用`闭包`或`bind()`来实现偏函数

   ```js
   //使用闭包来实现,首先定义一个多参数函数
   function sum(a, b, c) {
       console.log(a + b + c)
   }
   //定义一个处理函数(函数本体,固定的参数)
   function partial(fn, ...args) {
       //返回一个新函数(剩余参数,未固定的参数)
       return function (...args2) {
           //利用闭包调用原函数,传入第一次的参数+第二次的参数
           fn.call(this, ...args, ...args2)
       }
   }
   let nSum = partial(sum, 10)//接收返回的函数
   nSum(10, 10) 	//a + b + c = 30
   ```

2. 柯里化

   柯里化是一项将一个函数的调用形式为`f(a,b,c)`转换为`f(a)(b)(c)`的形式,就叫做柯里化

   ```js
   //定义一个需要处理的函数
   function sum(a, b, c) {
       console.log(a + b + c)
   }
   //定义处理函数(函数本体)
   function curry(fn) {
       //直接返回函数repeat(第一次传入的参数)
       return function repeat(...args) {
           //判断传入参数是否大于等于函数的形参
           if (args.length >= fn.length) {
               //执行原函数
               return fn(...args)
           } else {
               //返回一个新函数用来接收剩余参数
               return function (...args2) {
                   //使用递归调用自身,实现循环
                   return repeat(...args, ...args2)
               }
           }
       }
   }
   let nSum = curry(sum)
   
   nSum(10)(10)(10)
   nSum(10, 10)(10)
   ```

### 缓存函数

将自身的结果储存在一个对象中，

下次调用时，判断该对象是否拥有对应属性，

如果拥有，则直接返该属性的值

没有，则添加后返回该属性的值

## 防抖/节流

**防抖/节流** -> 稀释函数的触发方式

**防抖:**

- 持续触发时,小于间隔时间,不发触发请求
- 最后一次会触发函数

**节流:**

- 规定时间内,只触发一次

**使用防抖/节流的两种方式:**

1. 使用loadsh函数库,提供的防抖和节流的函数库
2. 自行封装代码
