# 对象(Object)

> 对象中带()是方法,不带是属性

1. 对象是一种复合数据类型
2. 当两个对象进行全等比较时,比较的是对象的**内存地址**
3. 两个变量指向同一个对象时,通过修改,会影响到另外一个变量

## 1.属性

1. 通常属性名是一个字符串,所以属性名可以是任何值,没有特殊需求

2. 如果属性名太特殊了,不能直接使用,需要使用[]设置

3. 也可以使用[(Symbol)](./02-数据类型.md#Symbol)作为属性名,来添加属性 

   > 一般通过`Symbol( )`添加的属性,是不希望被修改的,隐藏的

### 1.1检查对象是否拥有某个属性

1. `obj.hasOwnProperty('属性名')`检查自身是否拥有某个属性(不推荐使用)

2. `Object.hasOwn(对象,属性名)`(推荐使用)

3. `in` 运算符 , `xxx in obj` 

   -> 无论在自身还是原型中都会返回true

### 1.2枚举对象属性

枚举:将对象中所有的属性全部获取

1. `console.dir(obj)` 在控制台输出该对象所有属性/方法
2. 使用`for-in`语句,进行枚举

```js
for(let i in 对象){
	console.log(对象[i])					
}
//for-in的循环体会执行多次,有几个属性就会执行几次
//每次执行时,会将一个属性名赋值给i
```

> **注意 :** 并不是所有的属性都已枚举
>
> 比如:使用`Symbol()`添加的属性

3. 下列三个对象都可用于对象属性的枚举
   1. `Object.keys(obj)` -> 返回数组,数组元素为对象自身属性名
   2. `Object.values(obj)` -> 返回数组,数组元素为对象自身属性值
   3. `Object.entries(obj)` -> 返回数组,数组元素为对象自身属性名+属性值

## 2.类(class)

类(clss)是对象的模版,可以将对象中的属性或方法直接定义在类中

1. 定义好一个类后,可以直接通过[new运算符](#4.new运算符)创建对象
2. 同一个类创建的对象,为**同类对象**
3. 使用`instanceof`,检查一个对象是否由某个类创建

```js
//使用new运算符创建该类的实例
let M1 = new MyObj();
console.log(M1 instanceof MyObj)	//true
```


4. 通过类创建的对象,为该类的实例

```js
//通过class创建一个类,使用大驼峰命名法
class MyObj{
    //通过加 sratic创建静态属性,
    sratic test = '静态属性'	//静态属性只能通过类进行访问
	//新对象创建时,constructor函数会运行
	constructor(name){
		this.name = name
    }
}
```

### 旧类[(构造函数)](06-函数#构造函数)

通过function创建一个构造函数 -> `cunstructor`就是构造函数

## 3.原型对象

对象中有一个存储原型对象的对象`__proto__`

1. **原型对象也负责为对象存储数据**

   1. 访问对象中的属性时,会优先在自身寻找
   2. 自身不包含该属性,则去顺着原型链找,不存在则返回undefined

2. **向原型对象中添加属性/方法**

   1. 在类中,通过`xxx(){}`添加的方法
   2. 主动像原型中添加的属性/方法

3. **访问原型对象**

   1. `obj.__proto__`
   2. `Object.getPrototypeof(对象)` 返回该对象的原型对象

4. **获取构造函数的原型对象**

   -> `fn.prototype`

   > 实例化对象的原型指向构造函数的原型

5. **检查对象是否为某个对象的原型**

   `fn.prototype.isPrototypeOf(obj)`

6. **原型中的数据**

   1. 对象中的数据

   2. `cunstructor`(指向对象本身)

> 原型对象也有原型,这样构成一条原型链
>
> 对象的复杂程度不同,原型链的长度也不同

## 4.new运算符

通过new调用一个函数时,这个函数会作为构造函数使用

使用new实例化一个对象,会发生以下事件:

1. 创建一个普通对象`{ }`,称之为新对象
2. 将构造函数的`prototype`属性设置为新对象的原型`__proto__`
3. 使用实参来执行构造函数,并将新对象设置为函数中的`this`
4. 构造函数的返回值:
   - 当返回值是一个`引用值`时,该值会作为new运算的返回值返回(**千万不要这么做!**)
   - 返回值是一个原始值/没有指定返回值,则新对象`{ }`作为返回值
   - 通常构造函数不指定返回值

## 5. 封装 多态 继承

### 封装

1. 对象就是一个用来存储不同属性的容器

2. 对象不仅负责属性,还负责数据安全

3. 如何确保属性安全?

   1. 私有化数据

      在需要保护的数据前加上`#`,该属性只能在类内部使用

   2. 通过创建`getName()`和`setName()`方法,控制读写权限

      ```js
      class Person {
      	#name = "孙悟空"
      	getName(){
              return this.#name
          }
      	setName(name){
              this.#name = name;
          }//常规写法
      	get name(){
              return this.#name
          }
      	set name(name){
              this.#name = name;
          }//建议写法
      }
      ```

### 多态

1. JS中不会检查参数的类型,意味着任意数据类型都可以作为参数传递
2. 要调用某个函数,无需指定类型,只需要满足某些条件
3. 走路像鸭子,叫起来像鸭子,那么他就是鸭子,程序中判断鸭子,就只判断是否满足某些条件
4. 多态为我们提供了灵活性

### 继承

1. 可以通过extends关键字完成操作

   ```js
   p1 extends Person
   ```

2. 相当于一个类中的代码继承到了新类中

3. 被继承的类称为父类(超类),继承的类称为子类

4. 子类中,可以创建同名的方法覆写父类的方法

5. 通过继承可以在不修改一个类的情况下进行拓展类

## 6.属性描述符

数据属性描述符

```js
Object.defineProperty(对象,属性,{
	configurable:true, // 属性能否被配置
	enumerable:true, // 属性能否被遍历/枚举(for-in)
	writable:true, // 属性能否被修改
	value:29 // 设置属性的值
})
```

访问器属性描述符

```js
Object.defineProperty(对象,属性,{
	configurable:true, // 属性能否被配置
	enumerable:true, // 属性能否被遍历/枚举(for-in)
	get(){
        //读取属性时执行该函数
    }
	set(){
		//设置属性时执行该函数
	}
})
```

## 对象的方法

1. 作用:合并对象(经常用于[浅拷贝](./16-概念.md#浅拷贝与深拷贝)对象中)

   `Object.assign(目标对象,对象1,对象2...)`

   1. 将后续对象的属性添加到目标对象中
   2. 返回合并后的目标对象
   3. 同名属性,后面的属性覆盖前面的属性

2. 作用:枚举对象属性
   1. `Object.keys(obj)` -> 返回数组,数组元素为对象自身属性名
   2. `Object.values(obj)` -> 返回数组,数组元素为对象自身属性值
   3. `Object.entries(obj)` -> 返回数组,数组元素为对象自身属性名+属性值
